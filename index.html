<!DOCTYPE html>
<html>
  <head>
    <title>BOF3024 Learning Scala: A Practical Approach</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <textarea id="source">

class: bottom

# BOF3024 - Learning Scala: A Practical Approach

<img src="images/robert_treacy2.jpg" width="60" align="left" style="border:5px solid transparent" />
Bob Treacy ([@bobtreacy](https://twitter.com/bobtreacy))  
http://www.iq.harvard.edu/people/robert-treacy  
<br/>

<img src="images/michbarsinai.jpg" width="60" align="left" style="border:5px solid transparent" />
Michael Bar-Sinai ([@michbarsinai](https://twitter.com/michbarsinai))  
http://www.iq.harvard.edu/people/michael-bar-sinai  
http://mbarsinai.com

.right[[![IQSS logo](images/iqss-logo.png)](http://www.iq.harvard.edu)]

???

Hello! Thanks for coming. Let's get going.

This is Birds Of A Feather 3024, "Learning Scala: A Practical Approach ."

We are Michael Bar-Sinai and Bob Treacy, developers at the Institute for Quantitative Social Science at Harvard University.

---

class: bigfont

# Agenda

1. Intro
2. Why Scala?
3. Colliding Concepts
4. Tools
5. Tips

.regularfont[
Slides and code:

https://github.com/IQSS/javaone2014-bof5619
]

???

Here's the agenda for this talk.
* Intro
 * Who we are; Who is in the audience. Expectations
* Why Scala?
* Colliding Concepts
* Tools
* Tips

We will assume you have a working knowledge of java, and are interested in Scala but not sure how to start.
We will presents lessons we learned, so you could hit new problems

---

# Why Scala

* Implement a project based on a template that's relatively close to the final project
  * Such as Akka distributed worker template
* Try some functional programming
* Try some _postfunctional_ programming
>  if you look at the features Scala provides, it is substantially a functional language, but... it does not force you to adopt the functional style. I think .emph[postfunctional] is a good term for that blend.
.right[Martin Odersky, http://www.scala-lang.org/old/node/4960]
* Learn a new and interesting language

---
class: slide-emph-mid
name:colliding-concepts
# Colliding Concepts

While sharing the JVM, and Java's extensive libraries, Scala and Java are very different languages. Some words have different meanings. 

Intuitions created by years of working with Java can be misleading. You may end up doing as much _unlearning_ as you do _learning_.

It's a good thing, if you're ready for it.

.bottom.right[
So We've gathered a few examples.
]

---
layout: true

.slide-badge.badge.badge-1[
  Colliding<br />Concepts
]

---
name: syntax
#Syntax
* Semicolon inference<P>
	Of course all statements end with a semi-colon - doesn't mean you need to write it!
	two statements, one line
	one statement, multiple lines
		a line ending is treated as a semicolon unless:
			1.end in a word that would not be legal at the end of a statement
			2.next line begins with a word that cannot start a statement
			3.line ends while inside parentheses or bracket
* `return` keyword is often superfluous
		in the absence of an explicit return keyword, a method will return the last value computed
* `[]` are for type parameters, `<>` are for XML literals and operators, '()' and '{}' are interchangeable.
* Type name goes after the variable name
  - Personal goal: stop getting confused as early as Q3 of 2041.
* methods that return void (`def f() {...}`) vs those that return value (`def f()={...}`) 
<P>
def add(b: Byte): Unit ={
	sum += b
}
same as:
def add(b: Byte) { sum += b }

def checksum(): Int = {
	return ~(sum & 0xFF) +1
}
or 
def checksum(): Int = ~(sum & 0xFF) +1

???

--- 
# Method invocation

* the `obj method param` notation (as opposed to `obj.method(param)`)
* apply() method

```scala
class Foo(x: Int) {
    def apply(y: Int) = {
        x*x + y*y
    }
}

val f = new Foo(3)
f(4)   // returns 25
```
.todo[Michael: Not sure this is the best example, it includes currying which might be confusing]

---
# Companion objects vs. `static`
Explain the `object` keyword. Relate to class extensions (in Java, that's class annotations). Also relate to Javascript's object definition, which is pretty much the same.
Singleton

Utility methods

```scala
object Frontend {
  case object Ok
  case object NotOk
}

class Frontend extends Actor with ActorLogging {
  import Frontend._
  import context.dispatcher
  val mediator = DistributedPubSubExtension(context.system).mediator

  def receive = {
    case work:Work =>

      implicit val timeout = Timeout(5.seconds)
      log.info("received work: " + work + ":" + this.self)
      (mediator ? Send("/user/master/active", work, localAffinity = false)) map {
        case Master.Ack(_) => Ok
          log.info("Master ok")
      } recover { case _ => NotOk
          log.info("Master not ok")
      } pipeTo sender

  }

}
```

---
# Main
no `static` &rarr; no `public static void main`. 
main method vs. Application traits

---
# Object Creation
### `apply()` is the new `new`
creating objects without calling new
The object keyword - Object as “instance of class” vs scala's actual object

```

---
# List
Scala’s List vs. Java’s List

---
layout: true

---
# Collection Library
Java had minimal api (until 8), scala has maximal api
immutable vs mutable, same name different package
if the package is not imported or the full name is not used, default is immutable version

* Reference the official intro at http://docs.scala-lang.org/overviews/collections/introduction.html

---
class: slide-emph-mid
name:new-concepts
# New Concepts

Scala introduces many concepts that are not present in Java. Often, when you look at Scala code, it's unclear where values come from, how can objects extends so many classes, and so on.

This confused us too.

.bottom.right[
So We've gathered a few examples.
]

---
layout: true

.slide-badge.badge.badge-2[
  New<br />Concepts
]

---
#Traits vs interfaces

Traits define signatures of supported methods, like Java interfaces, but can also provide
default interfaces. Not quite the same as Java abstract class either

Mixin-  extends keyword
---
#Tuples

( 3, "Boston",199.5)
Tuple3()
 rank=t._1,city=t._2 Score=t._3
 Simple way to return multiple values from a method, maybe a survey result, where 
 semantic meaning is not important enough to pre-define a class to return the values
Don't overuse, remember objects are really annotated tuples (what's the semantics of the `String` value at `t._2`?)

Tuple22 is largest size
1-based index as in Haskell
---
# case classes
Pattern matching

from Work.scala --

case class Work(workId: String, job: Any)

case class WorkResult(workId: String, result: Any)

case class MethodParam(classifierId: String, model: String, params: java.util.List[Param])

case class WorkStatus(workId:String, done:Boolean)

case class TaskStatus(task:Task, subtasks: Int)

case class Param( name: String, value: Any)

automatic on declaration:
constructor parameters are vals unless explicitly declared var (no setters)
apply method is provided
unapply method is provided
toString, equals, hashcode and copy are generated unless explicitly provided
---
#Implicits

implict conversion
scope

implict parameters

implicit keyword

---
# `val` vs. `var`

* immutability bias
* Differences
* Throw in `def` as well?


---
layout: true

---
# Tools

* scala REPL
	
* IDEs
  * NetBeans
	* Intellij IDEA
	* Eclipse
  * Or, text editors such as SublimeText, Atom

* ScalaDoc
	
* SBT

---
class: bigfont
# Tips

  Spotting a good starter project
    Look at activator templates
    One-offs
    Scripts
  
  Resources
    Meetups
    Typesafe web-casts

---

# Don't Drink the FP Kool-Aid

.todo[Michael: I think this needs to be said, but if you feel it's too strong, we can take it out.]

Functional programming is great for some things, and not-so-great for others. It is somewhat hyped at the moment.

Scala, a .emph[postfunctional] language, allows you to choose the approach y
ou deem best, or just feel like trying. Don't be confused by the internets.

* Mutability is OK, as long as there's no concurrent updates
  - The locks and sync mechanisms are still there for you
  * Object creation and clean-up may be cheap, but it's not free!
  * Side-effects are hard to reason about formally. This is why we still have jobs.
* Tail recursion is not the best thing since slices bread
  * It's a way to coerce an recursive algorithm into a shape that will allow the compiler to further coerce it into a loop.
  * Makes total sense in Lisp, ML etc. where there are no loops.
  * You're writing in Scala. You can actually use a loop.
    * When you do use a tail recursion, don't forget `@tailrec`.

---
# Ease Into Functional Programming

.todo[show Code evolution of DataTags's markdown from java/procedural to map + fold.]


---

# Other Sessions

* Scala

* IQSS
	*CON575 - Bean Validation: Practical Examples from a Real-World Java EE 7 Application
	*BOF5619 - Lean Beans (Are Made of This)
	*BOF5475 - When the PrimeFaces Bootstrap Theme Isn't Enough

---
class: middle center

#Thanks
Visit the IQSS data science team at http://datascience.iq.harvard.edu


[![IQSS logo](images/iqss-logo.png)](http://www.iq.harvard.edu)
.bottom-remark[
Presentation created using remark.js.
]
    </textarea>
    <script src="js/remark-0.6.5.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
