<!DOCTYPE html>
<html>
  <head>
    <title>BOF3024 Learning Scala: A Practical Approach</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <textarea id="source">

class: bottom

# BOF3024 - Learning Scala: A Practical Approach

<img src="images/robert_treacy2.jpg" width="60" align="left" style="border:5px solid transparent" />
Bob Treacy ([@bobtreacy](https://twitter.com/bobtreacy))  
http://www.iq.harvard.edu/people/robert-treacy  
<br/>

<img src="images/michbarsinai.jpg" width="60" align="left" style="border:5px solid transparent" />
Michael Bar-Sinai ([@michbarsinai](https://twitter.com/michbarsinai))  
http://www.iq.harvard.edu/people/michael-bar-sinai  
http://mbarsinai.com

.right[[![IQSS logo](images/iqss-logo.png)](http://www.iq.harvard.edu)]

???

Hello! Thanks for coming. Let's get going.

This is Birds Of A Feather 3024, "Learning Scala: A Practical Approach ."

We are Michael Bar-Sinai and Bob Treacy, developers at the Institute for Quantitative Social Science at Harvard University.

---

class: bigfont

# Agenda

1. Intro
2. Why Scala?
3. Colliding Concepts
4. Tools
5. Tips

.regularfont[
Slides and code:

https://github.com/IQSS/javaone2014-bof3024F
]

???

Here's the agenda for this talk.
* Intro
 * Who we are; Who is in the audience. Expectations
* Why Scala?
* Colliding Concepts
* Tools
* Tips

We will assume you have a working knowledge of java, and are interested in Scala but not sure how to start.
We will presents lessons we learned, so you could hit new problems

---

# Why Scala

* Implement a project based on a template that's relatively close to the final project
  * Such as Akka distributed worker template
* Try some functional programming
* Try some _postfunctional_ programming
>  if you look at the features Scala provides, it is substantially a functional language, but... it does not force you to adopt the functional style. I think .emph[postfunctional] is a good term for that blend.
.right[Martin Odersky, http://www.scala-lang.org/old/node/4960]
* Learn a new and interesting language
* Bend your mind in new ways.

---
class: slide-emph-mid
name:colliding-concepts
# Colliding Concepts

While sharing the JVM, and Java's extensive libraries, Scala and Java are very different languages. Some words have different meanings. 

Intuitions created by years of working with Java can be misleading. You may end up doing as much _unlearning_ as you do _learning_.

It's a good thing, if you're ready for it.

.bottom.right[
So We've gathered a few examples.
]

---
layout: true

.slide-badge.badge.badge-1[
  Colliding<br />Concepts
]

---
name: syntax
#Syntax
### Semicolon inference
Of course all expressions end with a semi-colon - doesn't mean you need to write it!
* Two expressions, two lines
  ```scala
    print("hello, ")
    println("world!")
  ```

* Two expressions, one line
  ```scala
    print("hello, "); println("world!")
  ```
* One expression, multiple lines:
  a line ending is treated as a semicolon unless:
  1. end in a word that would not be legal at the end of a expression
  2. next line begins with a word that cannot start a expression
  3. line ends while inside parentheses or bracket

---

#Syntax

### []s, ()s and {}s
`[]` are for type parameters, `&lt;&gt;` are for XML literals and operators, '()' and '{}' are interchangeable.

### Type name goes after the variable name
  - Personal goal: stop getting confused as early as Q3 of 2041.

---

# Method invocation

* Methods that take no parameters may be invoked by just calling them - no need for `()` after the name.
```scala
      scala> def f()={ println("hello") }
      f: ()Unit
      scala> f // prints "hello"
      scala> f() // prints "hello"
      scala> f _
      res9: () => Unit = <function0>
```
* Single parameter methods can be invoked using an alternative to the dot-notation:<br />
  `a + b` is the same as `a.+(b)`
* Right associative methods: When last character of method name is `:` <br />
  `a +: b` is the same as `b.+:(a)`
* The `apply()` method - no need to type the `apply` part.<br />
  `f()` is really `f.apply()` or `f.apply`

???

* No-parameter functions may be invoked with no parens. 
* Reference the function itself via `f _`
* This allows better abstractions than getters, as the client code can't tell if they're calling a function or accessing a parameter.

---
# The Point of No `return`

All methods return values - there's no `void` return type.
If a method has nothing to return, it can return a value of type `Unit`.
These samples are functionally the same:

```scala
def add(b: Byte): Unit ={
	 sum += b
}
def add(b: Byte) { sum += b }

```

```scala

def checksum(): Int = {
	return ~(sum &amp; 0xFF) +1
}
def checksum(): Int = ~(sum &amp; 0xFF) +1
```

`return` keyword is often superfluous.<br/>
In the absence of an explicit return keyword, a method will return the last value computed.
`return` is useful as a type of `break` that returns a value.
???
.todo[Adjust code sample, maybe add return from inline anon func.]

---
# Companion objects vs. `static`

```scala
object Frontend {
  case object Ok
  case object NotOk
}

class Frontend extends Actor with ActorLogging {
  import Frontend._
  import context.dispatcher
  val mediator = DistributedPubSubExtension(context.system).mediator

  def receive = {
    case work:Work =>

      implicit val timeout = Timeout(5.seconds)
// ...
  }

}
```

---
# Main
no `static` &rarr; no `public static void main`. 

main method vs. Application traits

```scala
 def main(args: Array[String]): Unit = {
// ...
  }

```

```scala
object myApplication extends Application {

}

```
---
# Object Creation
### `apply()` is the new `new`
creating objects without calling new

```scala
class Fraction(n:Int, d: Int) {
	...
}

object Fraction {
   def apply(n: Int, d:Int) = new Fraction(n,d)
}   


val result = Fraction(3,4) * Fraction(2,5)

```


---
# What Do Mean By `List`?

## Java's `List`
Ordered collection of elements. 

## Scala's `List`
The classic linked list from CS 101 / intro to functional programming (with some extras thrown in, and without the annoying TA).

<br />
<br />
<br />
.center.emph[When you want a Java type of `List`, use Scala's `Seq` or `Buffer`]

---
layout: true

---
# Collection Library
Java had minimal api (until 8), scala has maximal api <br />
immutable vs mutable, same name different package
if the package is not imported or the full name is not used, default is immutable version

* Reference the official intro at http://docs.scala-lang.org/overviews/collections/introduction.html

---
class: slide-emph-mid
name:new-concepts
# New Concepts

Scala introduces many concepts that are not present in Java. Often, when you look at Scala code, it's unclear where values come from, how can objects extends so many classes, and so on.

This confused us too.

.bottom.right[
So We've gathered a few examples.
]

---
layout: true

.slide-badge.badge.badge-2[
  New<br />Concepts
]

---
# `val` vs. `var`

* val - immutable value
* var - mutable value

* immutability bias
```scala
  val workerId = UUID.randomUUID().toString
  var currentWorkId: Option[String] = None
```

---
#Traits vs interfaces

Traits define signatures of supported methods, like Java interfaces, but can also provide
default interfaces. 

Mixin-  extends keyword
```scala
trait Startup {

  def startBackend(joinAddressOption: Option[Address], role: String): Address = {
//...
    joinAddress
  }
```  
```scala

object Main extends Startup {
// ...
}


```  
```scala
class Master(workTimeout: FiniteDuration) extends Actor with ActorLogging {

```
---
#Tuples

```scala
( 3, "Boston",199.5)
//Tuple3(Int, java.lang.String, Double)
rank=t._1,word=t._2 Score=t._3
```
 
 Simple way to return multiple values from a method, where semantic meaning is not 
 important enough to pre-define a class to return the values
Don't overuse, remember objects are really annotated tuples (what's the semantics of the `String` value at `t._2`?)

* Tuple22 is largest size
* 1-based index as in Haskell

---
# case classes
Pattern matching

```scala
object MasterWorkerProtocol {
  // Messages from Workers
  case class RegisterWorker(workerId: String)
  case class WorkerRequestsWork(workerId: String)
  case class WorkIsDone(workerId: String, workId: String, result: Any)
  case class WorkFailed(workerId: String, workId: String)

  // Messages to Workers
  case object WorkIsReady
  case class Ack(id: String)
}
```

automatic on declaration:
constructor parameters are vals unless explicitly declared var (no setters)
apply method is provided
unapply method is provided
toString, equals, hashcode and copy are generated unless explicitly provided

---

#case classes

```scala

  def receive = {
    case RegisterWorker(workerId) =>
      if (workers.contains(workerId)) {
        workers += (workerId -> workers(workerId).copy(ref = sender))
      } else {
        log.debug("Worker registered: {}", workerId)
        workers += (workerId -> WorkerState(sender, status = Idle))
        if (pendingWork.nonEmpty)
          sender ! WorkIsReady
      }
    case WorkerRequestsWork(workerId) =>
      if (pendingWork.nonEmpty) {
        workers.get(workerId) match {
// ...
            sender ! work
        }
      }
    case WorkIsDone(workerId, workId, result) =>
      workers.get(workerId) match {
// ... 
          sender ! MasterWorkerProtocol.Ack(workId)
      }


```

---

#Implicits

implict conversion<br />
	integrating with other libraries
	if compiler comes across a type error it will look for an appropriate conversion method

implict parameters<br />
	compiler will look for default values to supply with the function call

implicit keyword

---
layout: true

---
# Tools

* scala REPL
	
* IDEs
  * NetBeans
	* Intellij IDEA
	* Eclipse
  * Or, text editors such as SublimeText, Atom

* ScalaDoc
	
* SBT

---
class: bigfont
# Tips

* Spotting a good starter project
  * Look at activator templates
  * One-offs
  * Scripts
  
Resources
  * Meetups
  * Typesafe web-casts

---

# Don't Drink the FP Kool-Aid

Functional programming is great for some things, and not-so-great for others. It is somewhat hyped at the moment.

Scala, a .emph[postfunctional] language, allows you to choose the approach y
ou deem best, or just feel like trying. Don't be confused by the internets.

* Mutability is OK, as long as there's no concurrent updates
  - The locks and sync mechanisms are still there for you
  * Object creation and clean-up may be cheap, but it's not free!
  * Side-effects are hard to reason about formally. This is why we still have jobs.
* Tail recursion is not the best thing since slices bread
  * It's a way to coerce an recursive algorithm into a shape that will allow the compiler to further coerce it into a loop.
  * Makes total sense in Lisp, ML etc. where there are no loops.
  * You're writing in Scala. You can actually use a loop.
    * When you do use a tail recursion, don't forget `@tailrec`.


.bottom.right[
Having said that...
]
???
.todo[Michael: I think this needs to be said, but if you feel it's too strong, we can take it out.]


---
# Ease Into Functional Programming

Rewrite existing, Scala-with-Java-accent code using functional programming idioms.


### Case study: Re-writing in Scala.
Problem: Create a poor-man's Markdown to HTML conversion.

Input: Sequence of `String`s

Output: `p` and `ul` elements, according to Markdown rules.

---
layout: true

.slide-badge.badge.badge-2[
  Code<br />Rewrite
]

---
Initial code:

```scala
  def html1( rawStrings : Seq[String] ):String = {
    val cleaned = mutable.Buffer[String]()
    for ( l &lt;- rawStrings ) {
      cleaned += l.trim
    }
    val curUl = mutable.Buffer[String]()
    val html = mutable.Buffer[String]()
    for ( l &lt;- cleaned ) {
      if ( l.startsWith("*") ) {
        curUl += "<li>" + l.substring(1).trim + "</li>"
      } else {
        if ( ! curUl.isEmpty ) {
          html += "<ul>"+curUl.mkString + "</ul>"
          curUl.clear
        }
        html += "<p>" + l + "</p>"
      }
    }
    
    if ( ! curUl.isEmpty ) {
      html += "<ul>"+curUl.mkString + "</ul>"
    }
    return html.mkString
  }
```

---
Initial code:

```scala
  def html1( rawStrings : Seq[String] ):String = {
*    val cleaned = mutable.Buffer[String]()
*    for ( l &lt;- rawStrings ) {
*      cleaned += l.trim
*    }
    val curUl = mutable.Buffer[String]()
    val html = mutable.Buffer[String]()
    for ( l &lt;- cleaned ) {
      if ( l.startsWith("*") ) {
        curUl += "<li>" + l.substring(1).trim + "</li>"
      } else {
        if ( ! curUl.isEmpty ) {
          html += "<ul>"+curUl.mkString + "</ul>"
          curUl.clear
        }
        html += "<p>" + l + "</p>"
      }
    }
    
    if ( ! curUl.isEmpty ) {
      html += "<ul>"+curUl.mkString + "</ul>"
    }
*    return html.mkString
  }
```
???

Easy re-writes: use map (the verb, vs map-the-noun). Remove the `return` keyword.

---
Somewhat more functional:

```scala
def html2( rawStrings : Seq[String] ) = {
*  val cleaned = rawStrings.map( _.trim )

  val curUl = mutable.Buffer[String]()
  val html = mutable.Buffer[String]()
  for ( l <- cleaned ) {
    if ( l.startsWith("*") ) {
      curUl += "<li>" + l.substring(1).trim + "</li>"
    } else {
      if ( ! curUl.isEmpty ) {
        html += "<ul>"+curUl.mkString + "</ul>"
        curUl.clear
      }
      html += "<p>" + l + "</p>"
    }
  }
  
  if ( ! curUl.isEmpty ) {
    html += "<ul>"+curUl.mkString + "</ul>"
  }
*  html.mkString
}
```
???
That was easy.
---
Somewhat more functional:

```scala
def html2( rawStrings : Seq[String] ) = {
  val cleaned = rawStrings.map( _.trim )

*  val curUl = mutable.Buffer[String]()
*  val html = mutable.Buffer[String]()
*  for ( l <- cleaned ) {
*    if ( l.startsWith("*") ) {
*      curUl += "<li>" + l.substring(1).trim + "</li>"
*    } else {
*      if ( ! curUl.isEmpty ) {
*        html += "<ul>"+curUl.mkString + "</ul>"
*        curUl.clear
*      }
*      html += "<p>" + l + "</p>"
*    }
*  }
*  
*  if ( ! curUl.isEmpty ) {
*    html += "<ul>"+curUl.mkString + "</ul>"
*  }
  html.mkString
}
```
???
* It is not as clear how to convert this part. But it clearly can be done, since we're processing a list, as in LISP.
* Can we use some `fold` variant?
---
Somewhat more functional:

.modal[
```
Seq(1,2,3,4).foldLeft(0)( (p,i)=>p+i )
// yields 10
```
]

```scala
def html2( rawStrings : Seq[String] ) = {
  val cleaned = rawStrings.map( _.trim )

*  val curUl = mutable.Buffer[String]()
*  val html = mutable.Buffer[String]()
*  for ( l <- cleaned ) {
*    if ( l.startsWith("*") ) {
*      curUl += "<li>" + l.substring(1).trim + "</li>"
*    } else {
*      if ( ! curUl.isEmpty ) {
*        html += "<ul>"+curUl.mkString + "</ul>"
*        curUl.clear
*      }
*      html += "<p>" + l + "</p>"
*    }
*  }
*  
*  if ( ! curUl.isEmpty ) {
*    html += "<ul>"+curUl.mkString + "</ul>"
*  }
*  html.mkString
}
```
???
* Fold a list of items to a product.
* Only we want to end with a List
* So, start with `List[List[String]]`
---

Even more functional:

```scala
def html3( rawStrings : Seq[String] ) = {
  val elements = rawStrings.map( _.trim )
                   .map( s => if (s.startsWith("*"))
                                {"<li>"+s.substring(1).trim+"</li>"}
                              else
                                {"<p>" + s + "</p>"} )

  val grouped = elements.tail.foldLeft( List(List(elements.head)) )(
                   (l,s) => { 
                      if ( l.last.head(1) != s(1) ) 
                          l :+ List(s)
                      else
                          l.dropRight(1) :+ (l.last :+ s)
                      })

  grouped.flatMap( l => if (l.head.startsWith("<li>")) 
                          List("<ul>"+l.mkString+"</ul>")
                        else
                           l 
                  ).mkString
}
```
Using `foldLeft`, we create a list of lists of `String`s, and operate on them. Then, use `flatMap` to convert the result to a list of strings, and then use `mkString` to create the final string.


.bottom-remark[Actual code included in presentation repo at GitHub.]

???
* Code looks better when not confined to a slide
---
layout: true

---
# Other Sessions

* Scala

* IQSS
    * CON575 - Bean Validation: Practical Examples from a Real-World Java EE 7 Application
    * BOF5619 - Lean Beans (Are Made of This):Command Pattern Versus MVC
    * BOF5475 - When the PrimeFaces Bootstrap Theme Isn't Enough

---
class: middle center

#Thanks
Visit the IQSS data science team at http://datascience.iq.harvard.edu


[![IQSS logo](images/iqss-logo.png)](http://www.iq.harvard.edu)
.bottom-remark[
Presentation created using remark.js.
]
    </textarea>
    <script src="js/remark-0.6.5.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
